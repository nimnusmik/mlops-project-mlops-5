## 1. PostgreSQL이란?

- **서버1에서는** 크롤링한 영화 원천 데이터, 전처리·피처엔지니어링 결과, 임시 실험 이력 등 **모든 정형 데이터(테이블 형태)**를 안전하게 저장·관리하기 위해 PostgreSQL을 사용.
- 데이터 적재(수집), 임시 가공, EDA 결과, 산출물 저장까지 전체 데이터 흐름의 출발점이자, 서버2/3와 연동되는 중간 허브 역할.

---

- **프로그래밍적 예시**
    - TMDB API에서 크롤링한 DataFrame을 `.to_sql()`로 PostgreSQL의 `movies_raw` 테이블에 저장.
    - 전처리 후 파생된 피처셋을 `features` 테이블에 저장해, 추후 실험/재현 시 활용.
    - SQL로 “2023년 이후 개봉 영화만”, “결측치 없는 행만” 등 조건 검색·집계.
    - EDA(기초통계, 분포) 결과도 별도 테이블로 기록하여 여러 실험 결과를 체계적으로 관리.
    - 실험 이력, 피처 엔지니어링 로그 등 중간 결과를 테이블별로 분리 저장, 서버2/3와 연동시 데이터 추적이 용이.
- **초보 개발자용 비유적 예시**
    - 서버1의 PostgreSQL은 모든 실험 데이터를 디지털 엑셀로 저장하는 강력한 금고.
    - Git이 코드 버전 관리를 하듯, 실험별 데이터/산출물을 테이블별로 누적 관리.
    - 원하는 행/열만 조건 필터해 git diff처럼 비교, 실험 간 변화 분석.
    - 실험/전처리 담당자가 바뀌어도 DB에 데이터만 남아 있으면 업무 연속·재현 쉬움.
    - 크롤링·EDA·피처·실험까지 모든 단계별 데이터 히스토리가 이 DB에 기록됨.
- **실생활 예시**
    1. **전화번호부 노트**
        - 새로 들어온 영화, 피처, 실험 결과까지 한눈에 표로 관리.
        - 연락처(데이터)가 바뀌면 수정만 하면 되고, 기록은 모두 남음.
        - 팀원 모두 같은 기준(테이블 구조)으로 정보 공유.
        - 수년치 데이터도 한 권의 표로 정리해 손쉽게 추적.
        - 신규 담당자가 와도 표만 보면 업무 인수인계가 빠름.
    2. **학생 성적표**
        - 학기별, 학생별, 과목별 점수가 모두 누적 관리.
        - 평균·상위권 분석 등 조건 검색도 표 하나면 가능.
        - 성적표가 바뀌면 업데이트, 과거 기록도 그대로 보관.
        - 여러 반(실험, 피처 등)도 같은 성적표 양식으로 관리.
        - 누구나 성적표만 보면 성적 추이·분석이 바로 됨.
    3. **도서관 대출 기록표**
        - 책(데이터)마다 언제 들어왔고, 누가 빌렸고, 어떤 상태였는지 기록.
        - 대출/반납 내역, 인기 순위 등 각종 통계도 한눈에 확인.
        - 기록이 남으니 오래된 책, 신간 모두 추적 가능.
        - 새 책 입고(신규 데이터)는 추가만 하면 끝.
        - 실험 결과, 데이터 관리, 히스토리 파악에 최적화.

---

## 2. S3란?

- **서버1에서는** 크롤러 결과, 대용량 원본/피처 데이터, 임시 전처리 산출물, 모델 파일 등 **비정형 파일 전체를 안전하게 백업/공유/연동하기 위해 S3를 사용**.
- 서버1의 산출물이 서버2/3와 쉽게 연동·재활용되고, 데이터 손실·장애에도 안전하게 복구 가능.

---

- **프로그래밍적 예시**
    - 크롤러가 저장한 `raw_data_20250801.csv` 파일을 `boto3`로 S3 버킷(`my-mlops-raw-data/`)에 업로드.
    - JupyterLab에서 S3에 저장된 `.parquet` 파일을 바로 불러와 분석/EDA/피처 생성 반복.
    - 실험 결과(모델 파일 등)를 S3에 저장해, 서버2/3에서 모델 추론/서빙에 즉시 활용.
    - 대용량 데이터도 인터넷만 되면 언제든 저장·복구, 실험 실패 시에도 즉시 복원 가능.
    - S3 버킷 내 폴더/파일명 규칙화로 각 실험/산출물 관리도 체계적.
- **초보 개발자용 비유적 예시**
    - 서버1의 S3는 모든 실험 파일을 구글 드라이브처럼 안전하게 보관·공유하는 인터넷 저장소.
    - Git으로 코드를 안전하게 푸시/백업하듯, 실험 산출물을 S3에 올려두면 팀 전체와 즉시 공유.
    - 데이터가 커도 로컬 디스크 용량 걱정 없이 파일을 쌓아둘 수 있음.
    - 실험별/날짜별 폴더 구조로 정리해, git branch/commit처럼 파일을 구분·관리.
    - 파일을 실수로 날려도, S3에서 복구하면 손실 걱정 끝.
- **실생활 예시**
    1. **구글 드라이브**
        - 모든 파일/실험 결과를 인터넷에 안전하게 저장, 필요할 때 꺼내 쓰기.
        - 여러 팀원이 같은 파일을 동시에 접근·활용.
        - 장애/실수/포맷에도 S3에 백업된 파일로 즉시 복구.
        - 대용량 파일도 공간 걱정 없이 장기간 관리.
        - 파일 버전/폴더별로 구분해 쉽게 찾고 공유.
    2. **대형 창고**
        - 크고 작은 물건(데이터 파일)을 무한대로 쌓아두는 창고.
        - 물건 종류별로 박스·선반(폴더)로 구분, 효율적 보관.
        - 창고지기(프로그램)에게 요청하면 필요한 물건만 꺼내 사용.
        - 창고가 무너지거나 분실 위험 없이 오래 보관.
        - 다른 창고(서버2/3)와도 쉽게 물건을 옮김.
    3. **USB/외장하드 업그레이드**
        - 팀 프로젝트 파일을 각자 USB로 들고 다니던 시절 대신, S3에 올려서 언제든 다운로드.
        - 여러 명이 동시에 파일을 업로드/다운로드해도 혼잡 없음.
        - 용량 제한 없는 안전한 저장, 자료 유실 걱정 해소.
        - 폴더별 정리로 실험별/파일별 관리도 쉬움.
        - PC가 바뀌어도 S3만 연결하면 언제든 업무 재개.

---

## 3. Feast란?

- **서버1에서는** 전처리·피처 엔지니어링 후 생성된 **학습용 피처 데이터 전체를 정의/버전 관리/배포/동기화**하기 위해 Feast를 사용.
- 실험/배포 환경의 피처 일관성, 코드 기반 피처 재사용·관리·협업 보장.

---

- **프로그래밍적 예시**
    - 전처리·피처 엔지니어링 스크립트에서 FeatureView 클래스로 피처 집합 선언 후, Feast로 저장.
    - S3(Offline Store)에 저장된 학습 피처셋을 Feast CLI로 materialize, Redis(Online Store)에도 동기화.
    - 피처 정의 변경(추가/수정/삭제) 시 Python 코드만 고치면 전체 파이프라인에 자동 반영.
    - 서버1 실험에서 사용한 피처 버전을 정확히 추적·재현.
    - 여러 명이 FeatureView/Entity를 같이 관리해도, 충돌 없이 자동 버전 관리.
- **초보 개발자용 비유적 예시**
    - 서버1의 Feast는 피처(데이터 변수) 정의를 Python 코드로 정리·버전 관리하는 “피처 깃 저장소”.
    - Git에서 각 기능(브랜치)을 코드로 관리하듯, 각 피처 집합도 코드(FeatureView)로 관리.
    - 피처가 추가/삭제돼도 코드만 바꾸면 전체 실험에 자동 적용, 실험별 피처 차이도 기록.
    - 코드로 피처 관리하니, 실험이 많아져도 관리 복잡도 최소화.
    - 팀원이 바뀌어도, FeatureView 코드만 있으면 피처 재현/확장 가능.
- **실생활 예시**
    1. **영양성분표가 붙은 식재료 창고**
        - 피처(데이터 변수)마다 영양정보를 표로 체계적으로 기록.
        - 새로운 재료(피처)가 생기면 표 업데이트, 과거 내역도 남음.
        - 요리(실험)할 때마다 동일 기준으로 재료 사용.
        - 영양성분표(FeatureView)만 있으면 실패·중복 걱정 없음.
        - 새 요리사가 와도 표대로만 관리하면 실수 없음.
    2. **자동 업데이트 레시피북**
        - 요리법(피처정의)이 코드로 기록되어 언제든 최신화.
        - 레시피가 바뀌어도 자동으로 새 책 전체에 반영.
        - 여러 명이 같이 써도 충돌 없이 버전 관리.
        - 실수/변경 이력도 모두 기록.
        - 요리 초보도 레시피북만 있으면 똑같이 요리.
    3. **출근부/근태관리 시스템**
        - 직원별, 월별, 규칙별로 출근 정보(피처)를 자동 기록.
        - 규칙(엔티티/피처)만 바뀌면 전체 시스템에 바로 적용.
        - 관리자 바뀌어도 이전 기록, 규칙 모두 관리.
        - 실시간 집계/월별 리포트도 자동 생성.
        - 일관성·재현성 걱정 없는 관리 시스템.

---

## 4. Redis란?

- **서버1에서는** Feast의 Online Store로 Redis를 사용해, **피처 데이터의 최신 버전(특히 실시간 예측용)을 초고속으로 저장/조회**함.
- 모델 실험/테스트 시 최신 피처를 바로 읽어서 빠르게 실험 반복, 서버2 실시간 API 서빙용 데이터 제공.

---

- **프로그래밍적 예시**
    - Feast materialize-incremental 명령으로, 최신 피처셋을 Redis에 동기화.
    - 예측/테스트 스크립트가 필요할 때마다 Redis에서 최신 피처만 key로 바로 조회.
    - TTL을 써서 일정 기간이 지나면 자동 삭제, 항상 최신 정보 유지.
    - 대량 실험·API 테스트 시에도 ms 단위 응답으로 처리 속도 보장.
    - 서버2(서빙)의 실시간 추론 요청에도 동일 데이터 동시 제공.
- **초보 개발자용 비유적 예시**
    - 서버1의 Redis는 “최신 데이터만 남긴 Python 딕셔너리”를 메모리에 저장, 실험·예측에 즉시 꺼내 쓰는 금고.
    - 자주 쓰는 변수/데이터만 미리 저장해두고, 필요할 때마다 key로 바로 꺼내 사용.
    - 오래된 데이터는 자동 삭제되어 항상 최신 상태 유지.
    - 실험 중 대량 요청이 들어와도 지연 없음.
    - 변수/피처만 기억하면, 반복 실험/테스트가 훨씬 쉬움.
- **실생활 예시**
    1. **냉장고 앞칸 신선식품**
        - 최신 피처만 앞칸에 넣어, 바로 꺼내 요리에 사용.
        - 시간이 지나면 자동으로 교체, 신선도 유지.
        - 여러 번, 여러 명이 동시에 꺼내도 접근 속도 빠름.
        - 오래된 재료는 자동 폐기, 공간 낭비 없음.
        - 최신 재료만 남으니 요리(실험) 효율 극대화.
    2. **도서관 신간 코너**
        - 최근 들어온 인기책(피처)만 별도 보관, 바로 대여.
        - 신간 기간이 지나면 코너에서 제외, 새 책으로 교체.
        - 누구나 신간을 쉽게 찾고 바로 읽음.
        - 대출/반납 기록도 신속히 관리.
        - 최신 트렌드·정보에 바로 접근.
    3. **책상 위 포스트잇**
        - 자주 참고할 정보만 포스트잇에 적어 책상 위에 붙임.
        - 쓸모없어지면 바로 떼고 새로 붙여 최신화.
        - 급히 필요할 때 바로 확인·활용.
        - 팀원이 바뀌어도 책상만 보면 정보 인수인계.
        - 필요한 정보가 즉시 보이고 관리 쉬움.

---

## 5. MLflow란?

- **서버1에서는** 모델 실험 결과(파라미터, 메트릭, 모델 파일 등)를 **자동 기록/비교/버전 관리/재현**하기 위해 MLflow를 사용.
- 여러 실험 결과를 체계적으로 비교, 최적 모델 선택, 실험 재현/복원, 서버2/3와의 실험 이력 공유.

---

- **프로그래밍적 예시**
    - `mlflow.start_run()`으로 실험 시작, 파라미터/결과를 자동 기록.
    - `mlflow.log_param`, `log_metric`으로 각 실험의 하이퍼파라미터/성능 기록.
    - 모델 파일(`.pkl` 등)은 `log_artifact`로 S3/로컬에 자동 저장.
    - 여러 번 실험 결과를 MLflow UI에서 시각적으로 비교·분석.
    - 실험별로 어떤 파라미터/데이터로 어떤 결과가 나왔는지 완벽 추적, 재실행 가능.
- **초보 개발자용 비유적 예시**
    - 서버1의 MLflow는 모델 실험 결과를 모두 자동 저장하는 “실험용 Git”.
    - 모델 실험을 할 때마다 커밋처럼 기록, 파라미터·성능까지 함께 저장.
    - 실험별 결과 비교는 git diff처럼 UI에서 바로 확인.
    - 언제든 과거 실험(커밋)으로 돌아가서 결과 복원/재실행 가능.
    - 실패/성공 실험도 모두 기록, 원인 분석·팀 공유·인수인계 쉬움.
- **실생활 예시**
    1. **요리 레시피 기록장**
        - 다양한 재료/방법으로 요리한 결과를 꼼꼼히 기록.
        - 어떤 레시피가 맛있는지 한눈에 비교.
        - 실패도 기록해 같은 실수 반복 안 함.
        - 친구와 레시피 공유, 여러 번 실험해 최고의 요리 선정.
        - 기록장 덕분에 실험 결과 재현 쉬움.
    2. **운동일지/다이어트 앱**
        - 날짜별, 운동별로 성과/방식/결과를 기록.
        - 이전 기록과 비교해 어떤 방법이 효과적인지 분석.
        - 실패도 남겨, 나중에 원인 분석·계획 수정.
        - 모든 기록을 앱 UI에서 차트로 시각화.
        - 계획 세우기, 목표 관리에 큰 도움.
    3. **시험 오답노트**
        - 여러 번 시험을 치르며 오답/정답/풀이를 기록.
        - 어떤 풀이가 효과적인지 비교·분석.
        - 오답 원인 기록, 다음엔 실수 반복 안 함.
        - 친구와 오답노트 공유, 풀이법 개선.
        - 과거 기록까지 한눈에 관리.

---

## 6. Airflow란?

- **서버1에서는** 데이터 크롤링 → 적재(PostgreSQL) → S3 백업 → 피처 생성(Feast) → 임시 모델 실험(MLflow 기록) 등 **모든 데이터 파이프라인의 전체 실행/일정/자동화 관리에 Airflow를 사용**.
- 실험, 전처리, EDA, 피처엔지니어링 등 복잡한 과정을 코드로 자동 실행·모니터링·재현.

---

- **프로그래밍적 예시**
    - 각 Task(크롤러, 전처리, 피처생성, 모델실험)를 Python 함수/클래스로 작성, DAG로 연결해 전체 파이프라인 구성.
    - “크롤링→DB 저장→S3 백업→Feast materialize→MLflow 기록”처럼 전체 흐름을 스케줄링(DAG)화.
    - 매일/매주/조건 충족 시 등 다양한 일정, 자동화 트리거로 반복 실행.
    - 실패/에러 시 자동 재시도, Slack 등 알림 설정.
    - Web UI에서 전체 작업 흐름/실행 결과/로그/성공·실패 이력 시각화.
- **초보 개발자용 비유적 예시**
    - 서버1의 Airflow는 Python 함수를 “자동 스케줄링+시각화+자동화”로 묶는 스마트 파이프라인 로봇.
    - GitHub Actions에서 빌드/테스트/배포 자동화하듯, 데이터 수집/전처리/실험 전 과정을 DAG로 자동 처리.
    - 작업을 순서대로 실행, 실패/성공을 기록하고 반복 실험도 스케줄 관리.
    - 각 Task가 어디서 막혔는지, 로그와 함께 바로 확인 가능.
    - 여러 명이 파이프라인을 동시에 수정/확장해도 관리가 쉬움.
- **실생활 예시**
    1. **세탁기 예약 세탁**
        - 빨래→헹굼→탈수 등, 순서대로 자동 실행.
        - 중간에 에러나면 자동 멈춤/재시도.
        - 매일/특정시간 반복 실행.
        - 진행상황 알림(슬랙) 등, 자동 리포트.
        - 세탁 기록도 한눈에 추적.
    2. **공항 수하물 처리 시스템**
        - 수하물 분류→검색→운반 등, 단계별 자동 처리.
        - 단계별 실패시 재처리, 전체 흐름 실시간 모니터링.
        - 다양한 항공편/조건에 맞게 유연하게 조정.
        - 각 단계별 처리 시간/실패율도 기록.
        - 공항 전체가 자동화로 효율 극대화.
    3. **체크리스트 앱 자동 알림**
        - 할 일 목록을 정해진 순서·조건대로 자동 알림/실행.
        - 단계별 완료/미완료 상태 추적.
        - 반복 작업은 예약 자동화.
        - 새 할 일 추가·삭제도 즉시 반영.
        - 모든 기록을 히스토리로 관리.

---

## 7. JupyterLab이란?

- **서버1에서는** 데이터 EDA, 전처리 실험, 피처엔지니어링, 모델 학습·평가, 코드·결과 기록 등 **데이터 분석·실험 전체를 대화형/반복/기록 중심으로 관리하기 위해 JupyterLab을 사용**.
- 실험 코드, 결과, 그래프, 해설, 수식 등을 한 곳에 정리·공유.

---

- **프로그래밍적 예시**
    - 각 단계(크롤링, EDA, 전처리, 모델 실험)를 셀 단위로 정리해 코드+설명+결과+그래프를 한 번에 관리.
    - 마크다운 셀로 각 실험의 의도/과정/해설을 곁들여, 실험 맥락까지 기록.
    - 실험별 .ipynb 파일을 저장/공유, 팀원과 공동 실험·검증.
    - 실패한 코드/실패 케이스도 그대로 남겨, 나중에 원인 분석·재활용.
    - 실험별로 다양한 조건/코드를 셀 단위로 비교/변경 반복.
- **초보 개발자용 비유적 예시**
    - 서버1의 JupyterLab은 코드, 주석, 실행 결과, 그래프까지 한눈에 정리하는 “인터랙티브 코딩 연습장”.
    - Git이 버전별 코드 관리를 하듯, JupyterLab은 실험별 코드/결과를 셀 단위로 누적 관리.
    - 실험 실패/성공 기록을 모두 남겨, 나중에 분석·참조·복기 쉬움.
    - .ipynb 파일로 팀원과 코드+분석+결과를 같이 공유.
    - 셀을 복사·수정하며 여러 가지 실험을 동시에 반복/비교.
- **실생활 예시**
    1. **수학 문제 풀이 연습장**
        - 문제, 풀이, 정답, 해설을 한 페이지에 차곡차곡 기록.
        - 잘못된 풀이도 남겨 실수 원인 분석·반복 방지.
        - 새로운 문제를 추가해 연습/비교 반복.
        - 그림/그래프도 한 페이지에 붙여 설명 강화.
        - 노트가 쌓이면 나만의 노하우 노트북.
    2. **레시피북/요리 노트**
        - 재료, 과정, 결과 사진까지 한 페이지에 정리.
        - 성공/실패 요리 모두 기록, 노하우 축적.
        - 단계별 요리 과정 쉽게 따라 하도록 기록.
        - 친구와 노트를 공유해 요리법 전수.
        - 시간이 지나도 노트를 열어 기억·참조.
    3. **과학 실험 일지**
        - 준비물, 실험 방법, 관찰 결과, 해석을 차례로 기록.
        - 각 단계마다 사진/그래프/표로 시각적 설명 추가.
        - 실험 실패도 기록해, 원인 분석·개선 가능.
        - 나중에 같은 실험 반복시 참고 자료로 활용.
        - 여러 명이 일지를 공유해 더 좋은 결과 도출.
